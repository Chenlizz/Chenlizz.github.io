<!DOCTYPE html>
<html>
    <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="content-type" content="text/html">
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    
    <link href="/deps/partial/imgs/favicon.ico" type="image/x-icon" rel="icon">
    
    <title>
    
        HTML5-WebWorker | CLZ要长大
    
    </title>
        <link href="/deps/css/style.css" type="text/css" rel="stylesheet">
        <script src="/deps/js/jquery.min.js" type="application/javascript"></script>
        <link href="/deps/partial/mincss/nprogress.min.css" type="text/css" rel="stylesheet">
        <script src="/deps/js/nprogress.min.js" type="application/javascript"></script>
    
        <link href="/deps/partial/mincss/prism.min.css" type="text/css" rel="stylesheet">
        <script src="/deps/js/prism.min.js" type="application/javascript"></script>
        
    
</head>
    <body>
        <header class="header fixed-header">
    <div class="header-container">
        <a class="home-link" href="/">
            CLZ要长大
        </a>
        <ul class="right-list">
            
                <li class="list-item">
                    
                        <a href="/" class="item-link">Home</a>
                    
                </li>
            
                <li class="list-item">
                    
                        <a href="/archive/" class="item-link">Archive</a>
                    
                </li>
            
        </ul>
        <div class="menu-mask">
            <ul class="menu-list">
                
                    <li class="menu-item">
                        
                            <a href="/" class="menu-link">Home</a>
                        
                    </li>
                
                    <li class="menu-item">
                        
                            <a href="/archive/" class="menu-link">Archive</a>
                        
                    </li>
                
            </ul>
        </div>
    </div>
</header>
        <div id="article-banner">
    <h2>HTML5-WebWorker</h2>
    <p class="post-date">08/14/2019</p>
</div>
<main class="app-body flex-box">
    <article class="post-article">
        <section class="markdown-content">
            <h2 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h2><p>众所周知，JavaScript 是单线程的。Web Worker 的作用，就是为 JavaScript 创造多线程环境。主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。目的是，为主线程分担一些含耗时较大的算法代码或高延迟任务。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ol>
<li><p>创建新的Worker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var worker = new Worker(&apos;work.js&apos;);</span><br></pre></td></tr></table></figure>

<p><em>Worker()</em> 构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。</p>
</li>
<li><p>传递参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(&apos;hello&apos;)</span><br></pre></td></tr></table></figure>

<p>该方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。这种通信是拷贝关系，即是传值而不是传址。Worker 对通信内容的修改，不会影响到主线程。</p>
</li>
<li><p>接收消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 主线程</span><br><span class="line">worker.onMessage = function(event)&#123;</span><br><span class="line">  console.log(&apos;Received message &apos; + event.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Worker线程</span><br><span class="line">self.addEventListener(&apos;message&apos;, function (e) &#123;</span><br><span class="line">  self.postMessage(&apos;You said: &apos; + e.data);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">this.addEventListener(&apos;message&apos;, function (e) &#123;</span><br><span class="line">  this.postMessage(&apos;You said: &apos; + e.data);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">addEventListener(&apos;message&apos;, function (e) &#123;</span><br><span class="line">  postMessage(&apos;You said: &apos; + e.data);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息，从事件对象的data属性中获取Worker发来的数据。</p>
<p>Worker 线程中self代表子线程自身，即子线程的全局对象（Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以使用navigator对象和location对象）。除了使用self.addEventListener()指定监听函数，也可以使用self.onmessage指定。self.postMessage()方法用来向主线程发送消息。</p>
</li>
<li><p>异常处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">worker.onerror(function (event) &#123;</span><br><span class="line">  console.log([</span><br><span class="line">    &apos;ERROR: Line &apos;, e.lineno, &apos; in &apos;, e.filename, &apos;: &apos;, e.message</span><br><span class="line">  ].join(&apos;&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">worker.addEventListener(&apos;error&apos;, function (event) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭Worker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 主线程</span><br><span class="line">worker.terminate();</span><br><span class="line"></span><br><span class="line">// Worker 线程</span><br><span class="line">self.close();</span><br></pre></td></tr></table></figure>

<p>使用完毕，为了节省系统资源，必须关闭 Worker。</p>
</li>
<li><p>Worker中加载其他脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importScripts(&apos;script1.js&apos;, &apos;script2.js&apos;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Web Worker还有以下注意点：</p>
<ul>
<li>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源，不能跨域加载JS。</li>
<li>Worker 线程不能执行alert()方法和confirm()方法，不能访问DOM，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</li>
<li>Worker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持）。</li>
<li>这种普通的webworker是当前页面专有的。然后还有种共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用的，接下来介绍如何使用SharedWorker实现标签页之间的通信。</li>
</ul>
</li>
</ol>
<h2 id="Shared-Worker"><a href="#Shared-Worker" class="headerlink" title="Shared Worker"></a>Shared Worker</h2><pre><code>SharedWorker可以被多个脚本共同使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)。</code></pre><ol>
<li><p>应用页面中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if (typeof Worker === &quot;undefined&quot;) &#123;</span><br><span class="line">  alert(&apos;当前浏览器不支持webworker&apos;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  let worker = new SharedWorker(&apos;worker.js&apos;) </span><br><span class="line">  worker.port.addEventListener(&apos;message&apos;, (e) =&gt; &#123;</span><br><span class="line">    console.log(&apos;来自worker的数据：&apos;, e.data)</span><br><span class="line">  &#125;, false)</span><br><span class="line"></span><br><span class="line">   // 显示指定worker.port.start()方法建立与worker间的连接</span><br><span class="line">  worker.port.start()</span><br><span class="line">  window.worker = worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取和发送消息都是调用postMessage方法，我这里约定的是传递&apos;get&apos;表示获取数据。</span><br><span class="line">window.worker.port.postMessage(&apos;get&apos;)</span><br><span class="line">window.worker.port.postMessage(&apos;发送信息给worker&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>其中worker.js中的内容<br>sharedWorker所要用到的js文件，不必打包到项目中，直接放到服务器即可。<br>worker.js和index.html在同一目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let data = &apos;&apos;</span><br><span class="line">onconnect = function (e) &#123;</span><br><span class="line">  let port = e.ports[0]</span><br><span class="line"></span><br><span class="line">  port.onmessage = function (e) &#123;</span><br><span class="line">    if (e.data === &apos;get&apos;) &#123;</span><br><span class="line">      port.postMessage(data)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      data = e.data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>页面A发送数据给worker，然后打开页面B，调用window.worker.port.postMessage(‘get’)，即可收到页面A发送给worker的数据。</p>
</li>
</ol>
<ul>
<li>因为客户端和webworker端的通信不像websocket那样是全双工的，所以客户端发送数据和接收数据要分成两步来处理。示例中会有两个按钮，分别对应的向sharedWorker发送数据的请求以及获取数据的请求，但他们本质上都是相同的事件–发送消息。</li>
</ul>
<h2 id="实现多标签页之前通信的其他方法"><a href="#实现多标签页之前通信的其他方法" class="headerlink" title="实现多标签页之前通信的其他方法"></a>实现多标签页之前通信的其他方法</h2><ol>
<li>webSocket</li>
<li>localStorage</li>
</ol>

        </section>
        </br>
        <div class="article-footer">
            </br>
            <p>本文可能过时失效，若需更新，请留言</p>
            <!-- <p>本博客文章均为原创，转载请注明来源</p> -->
        </div>
        
    <div class="nav-container">
        
            <a class="nav-right" href="/2019/08/05/单点登录（SSO）/">
                
                    单点登录（SSO）
                
                <span class="nav-arrow"> →</span>
            </a>
        
        
    </div>

        
    </article>
    
        <aside class="catalog-container">
    <div class="toc-main">
        <strong class="toc-title">Catalog</strong>
        
            <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Web-Worker"><span class="toc-nav-text">Web Worker</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#API"><span class="toc-nav-text">API</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Shared-Worker"><span class="toc-nav-text">Shared Worker</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#实现多标签页之前通信的其他方法"><span class="toc-nav-text">实现多标签页之前通信的其他方法</span></a></li></ol>
        
    </div>
</aside>
    
</main>

<script type="application/javascript">
(function(){
    var banner = "/deps/partial/imgs/banner.jpg"
    $('#article-banner').css({'background-image': 'url(' + banner + ')'})
    $('.header').removeClass('fixed-header')
})();
</script>


        <div class="scroll-top">
    <span class="arrow-icon"></span>
</div>
        <footer class="app-footer">
    <p class="copyright" align="center">
        &copy; 2019 陈黎姿博客 <a>(https://chenlizz.github.io/)<a/>
    </p>
</footer>

<script src="/deps/js/function.min.js" type="application/javascript"></script>


    </body>
</html>